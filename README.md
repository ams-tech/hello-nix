# hello-nixos-raspberrypi -- A sample NixOS project

## Background

[Nix](https://nix.dev/manual/nix/2.26/introduction) is a system-level package management tool.  This allows developers to construct reproducable systems using the [Nix Language](https://nix.dev/manual/nix/2.26/language/).

[NixOS](https://nix.dev/manual/nix/2.26/introduction.html?highlight=nixos#nixos) is a distro-level implementation of Nix.  Using NixOS allows Nix projects to "own" the underlying system at the OS level.

## Objective

The goal of this project is to demo a simple "hello world" project on a SBC, like the RaspberryPi.  This will be broken down into a collection of sub-projects, with each subproject serving to teach about a new Nix principle.

## Sub-Projects

### Sub-Project 0: Install Nix

To begin, [install Nix on your development box](https://nixos.org/download/).

You will then need to change some configuration settings.  Create/Open `~/.config/nix/nix.conf` and write the following to the file:

```
experimental-features = nix-command flakes
```

Restart your shell, then execute `nix flake --help` to verify the install.

### Sub-Project 1: "hello-world" Nix Flake

#### What are Flakes, and how do I make one?

A [Nix Flake](https://wiki.nixos.org/wiki/Flakes) is the standard structure for a Nix project.  It allows developers to create a project in a manner that automates the distrebution of external dependencies, and publish your own project in a manner that can be used by other Nix Flakes.

When creating a Flake, it is helpful to start with a template; thankfully Nix has several built-in project templates.  Run `nix flake show templates` and you'll see what's available on your system:

```
adam@malak:~/hello-world-2$ nix flake show templates
github:NixOS/templates/2557dc639215476df149ae6842a1ae94d60a884c?narHash=sha256-wkIx1uPjYVOOcho0SAknX3tw2U8vswKwC/uZ3U0HAxE%3D
├───defaultTemplate: template: A very basic flake
└───templates
    ├───bash-hello: template: An over-engineered Hello World in bash
    ├───c-hello: template: An over-engineered Hello World in C
    ├───compat: template: A default.nix and shell.nix for backward compatibility with Nix installations that don't support flakes
    ├───dotnet: template: A .NET application and test project
    ├───empty: template: A flake with no outputs
    ├───full: template: A template that shows all standard flake outputs
    ├───go-hello: template: A simple Go package
    ├───haskell-flake: template: A haskell-flake template
    ├───haskell-hello: template: A Hello World in Haskell with one dependency
    ├───haskell-nix: template: An haskell.nix template using hix
    ├───hercules-ci: template: An example for Hercules-CI, containing only the necessary attributes for adding to your project.
    ├───latexmk: template: A simple LaTeX template for writing documents with latexmk
    ├───pandoc-xelatex: template: A report built with Pandoc, XeLaTex and a custom font
    ├───python: template: Python template, using poetry2nix
    ├───ruby: template: Flake for building ruby gems
    ├───rust: template: Rust template, using Naersk
    ├───rust-web-server: template: A Rust web server including a NixOS module
    ├───simpleContainer: template: A NixOS container running apache-httpd
    ├───trivial: template: A very basic flake
    ├───typescript-p5js: template: A template combining a node webserver and a dev environment
            for frontend typescript development
    ├───typescript-pnpm: template: A template combining a node webserver and a dev environment
            for frontend typescript development
    └───utils-generic: template: Simple, all-rounder template with utils enabled and devShell populated
```

Lets use the `bash-hello` template to get a "hello-world" project:

`nix flake init -t templates#bash-hello`

Build the package with `nix build`

And run it with `./result/bin/hello`:

```
adam@malak:~/hello-nix/hello-world$ ./result/bin/hello 
Hello Nixers!
```

Lets disect what happened during these steps.

#### The `flake.nix` file

What's going on in the `flake.nix` file?  

* `description` is a one-line description of this flake, and can be viewed with `nix flake metadata`
* `inputs` describes the dependencies of this flake.  When you run `nix build`, `nix` downloads the dependencies, and passes them to the `outputs` section.  In our case, we depend on a `nixos` release from the [nixpkgs repository](https://github.com/NixOS/nixpkgs).  
* `outputs` is how we construct our flake -- the "output" of this flake is our "hello world" NixOS package, e.g. something that can be built/executed on a system running NixOS, and imported as a dependency in other flakes.

The `flake.nix` file generated by the template includes details that go beyond this tutorial, but inspecting it is a good starting point for common patterns used by the Nix community.

#### The `nix build` process

First, running `nix build` generated a `flake.lock` file.  This is used to ensure others use the *exact* commit has of whatever dependencies we call out when building & testing this on our own system.

The `nix build` then generates an executable suitable for our system; in our case, this is `result/bin/hello`. Lets look at this file:

```
cat result/bin/hello 
#! /nix/store/dzrvibwj2vjwqmc34wk3x1ffsjpp4av7-bash-4.4-p23/bin/bash
echo "Hello Nixers!"
```

`/nix/store/dzrvibwj2vjwqmc34wk3x1ffsjpp4av7-bash-4.4-p23/bin/bash` is the instance of `bash` associated with our `NixOS` isntall.  

This emphasizes an importent concept in Nix: building & distributing this `hello-world` package is done at the `flake` project level.  We do not build & distribute `hello-world` binaries for multiple platforms.  Instead, we build & distribute a NixOS Package, and let each NixOS install manage how it acquires and/or builds the components of each package.

#### Publishing our Flake

Publishing your flake is as simple as pushing to a website like `github`.  

You can run the project included in this repository with:

`nix shell github:ams-tech/hello-nix?dir=hello-world -c hello`

Note: Nix flakes typically aren't placed in subdirectories, but for the sake of this tutorial it's just easier this way.

### Sub-Project 2: Installing NixOS on a Raspberry Pi

Now we'll prepare a system image to bootstrap our RPi with NixOS.  We're on a Rpi5, so we will be using the [nixos-raspberrypi](https://github.com/nvmd/nixos-raspberrypi) flake.

#### Set Up Cross Compilation

Assuming you're on an x86_64 system, you'll need to set up a cross compiler for arm's `aarc64` toolchain.

Typically, this is done by setting up a cross-compilation toolchain; however, NixOS community workflows seem to favor compiling in emulated environments (or, at least, this was the first functional solution I found).

Install the appropriate qemu and binfmt tools, and verify it's functional:

```bash
sudo apt update
sudo apt install -y qemu-user-static binfmt-support

ls /proc/sys/fs/binfmt_misc/ | grep -E 'qemu-aarch64|aarch64' || true
```

Now enable aarch64 emulation in the Nix daemon.  Edit `/etc/nix/nix.conf`:

```
experimental-features = nix-command flakes

# allow building ARM derivations on this x86_64 host
extra-platforms = aarch64-linux

# make qemu-aarch64-static available inside Nix build sandboxes
extra-sandbox-paths = /usr/bin/qemu-aarch64-static
```

And restart the daemon: `sudo systemctl restart nix-daemon`

#### Build the Installer Image

Now you can build the installer image from the [nixos-raspberrypi project](https://github.com/nvmd/nixos-raspberrypi):

`nix build github:nvmd/nixos-raspberrypi#installerImages.rpi5`

This will be slow if you're using an emulated environment; even slower than typical yocto builds.

The build process is pretty quiet, but when successful, it will generate a file called `result` -- this is a symlink to the installer image.

Burn the image to your boot media (typically an SD card):

```bash
ls -R result

# if you find a .img.zst:
zstd -d result/**/*.img.zst -o nixos-rpi5.img

# write to SD/USB (DOUBLE-CHECK /dev/sdX):
sudo dd if=nixos-rpi5.img of=/dev/sdX bs=4M conv=fsync status=progress
```

Boot the image on your RPi with a monitor plugged in; it will set up a root SSH account with randomly generated credentials 

TODO: Add picture

### Sub-Project 3: Provision your new system

* Copy `provision-rpi5/flake.nix` to your raspberry pi 
* Run `nixos-rebuild switch --flake .#hello-nix-rpi5`